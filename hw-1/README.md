# Каталог фильмов - React + TypeScript веб-приложение

### Выполнил: Ткачук Артём Сергеевич, БПИ237

tg: https://t.me/zovimenyatyoma

## Основной функционал (оценка 8):

### Компоненты

- Используются Функциональные компоненты
- Разделение по файлам: `Header`, `Footer`, `MovieCard`, `MovieCatalog`
- Полная типизация TypeScript
- Нет ошибок компиляции

### Состояние и рендеринг

- `useState` для управления фильмами, фильтрами, режимом отображения
- `useRef` для доступа к input поиска
- Условный рендеринг на отсутствие фильмов
- Циклический рендеринг списка фильмов

### Функциональность

- Добавление, удаление из избранного
- Фильтрация: Все или Только избранные
- Поиск по названию
- Переключение режима отображения

---

## Улучшения для оценки 9

### Адаптивный дизайн

Приложение корректно отображается на всех устройствах:

- **Desktop** (> 1200px)
- **Малый комп или горизонтальный планшет** (1024-1199px) - 3 колонки
- **Вертикальный планшет** (768-1023px) - 2-3 колонки
- **Горизонтальный телефон** (576-767px) - 2 колонки
- **Вертикальный телефон** (< 576px) - 1 колонка
- **Маленькие экраны** (< 440px) - адаптация для строчного режима

Смотреть в файле `src/App.css`

### UX/UI улучшения

- Плавные анимации при наведении и взаимодействии
- Визуальная обратная связь для всех интерактивных элементов

---

## Продвинутые техники для оценки 10

### 1. React.memo для оптимизации рендеринга

**Что сделано:**

```typescript
const MovieCard = memo(function MovieCard({ ... }) {
  ...
});
```

- Оборачивает компонент и сравнивает его пропсы
- Если пропсы не изменились, React пропускает рендеринг

При наличии 9 карточек фильмов, без оптимизации происходит следующее:

- Пользователь добавляет **1 фильм** в избранное
- React перерисовывает **все 9 карточек**

С `React.memo`:

- React сравнивает пропсы каждой карточки
- Перерисовывается **только 1 изменённая** карточка
- **8 карточек** пропускают рендеринг

Смотреть в `src/components/MovieCard.tsx`

---

### 2. useMemo для мемоизации вычислений

**Что сделано:**

```typescript
// В MovieCatalog.tsx
const filteredMovies = useMemo(() => {
  return movies.filter((movie) => {
    // Фильтрация
  });
}, [movies, filter, searchQuery]);

// В App.tsx
const headerData = useMemo(
  () => ({
    title: "Каталог фильмов",
    description: "...",
  }),
  []
);
```

- `useMemo` кеширует результат вычислений
- Пересчёт происходит только при изменении зависимостей
- Возвращает закешированное значение, если зависимости не изменились

**Проблема без useMemo:**

```typescript
// При каждом рендере создаётся НОВЫЙ массив
const filteredMovies = movies.filter(...);
```

Если пользователь меняет `viewMode`:

1. Компонент перерисовывается
2. Создаётся новый отфильтрованный массив
3. Все дочерние компоненты получают новую ссылку на массив
4. React.memo не работает, тк ссылка изменилась
5. Все карточки перерисовываются

**С useMemo:**

- Фильтрация выполняется только при изменении `movies`, `filter` или `searchQuery`
- При изменении `viewMode` возвращается та же ссылка на массив
- React.memo видит, что пропсы не изменились
- Карточки не перерисовываются

**Результат:** Предотвращение ненужных вычислений и перерисовок, особенно при большом списке фильмов.

Смотреть в `src/components/MovieCatalog.tsx`, `src/App.tsx`

---

### 3. useCallback для оптимизации функций

**Что сделано:**

```typescript
const handleToggleFavorite = useCallback((id: number) => {
  setMovies((prevMovies) => ...);
  setFavoriteIds((prev) => ...);
}, [setFavoriteIds]);
```

- `useCallback` кеширует саму функцию
- Возвращает ту же функцию, если зависимости не изменились
- Создаёт новую функцию только при изменении зависимостей

**Проблема без useCallback:**

```typescript
// При каждом рендере создаётся НОВАЯ функция
const handleToggleFavorite = (id: number) => { ... };
```

Что происходит:

1. App перерисовывается, например, из-за изменения состояния
2. Создаётся новая функция `handleToggleFavorite`
3. `MovieCatalog` получает новую функцию в пропсах
4. `MovieCard` получает новую функцию
5. React.memo видит изменение пропсов
6. Все карточки перерисовываются

**С useCallback:**

```typescript
const handleToggleFavorite = useCallback(
  (id: number) => {
    // ...
  },
  [setFavoriteIds]
); // Зависимости
```

- Функция создаётся один раз
- При рендерах возвращается та же ссылка
- Пропсы компонентов не меняются
- React.memo работает корректно
- Карточки не перерисовываются без необходимости

**Связь с React.memo:**

```typescript
// MovieCard обёрнут в React.memo
const MovieCard = memo(function MovieCard({ onToggleFavorite }) {
  // Если onToggleFavorite это новая функция при каждом рендере,
  // React.memo бесполезен
  // useCallback делает React.memo эффективным
});
```

Смотреть в `src/App.tsx`

---

### 4. LocalStorage для сохранения избранного

**Что сделано:**

- Создан кастомный хук `useLocalStorage`
- Избранные фильмы сохраняются в браузере
- Данные восстанавливаются при перезагрузке страницы

**Как работает:**

```typescript
// Хук useLocalStorage
export function useLocalStorage<T>(key: string, initialValue: T) {
  // 1. При инициализации читаем из localStorage
  const [storedValue, setStoredValue] = useState<T>(() => {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });

  // 2. При изменении значения сохраняем в localStorage
  useEffect(() => {
    window.localStorage.setItem(key, JSON.stringify(storedValue));
  }, [key, storedValue]);

  return [storedValue, setStoredValue] as const;
}

// Использование в App.tsx
const [favoriteIds, setFavoriteIds] = useLocalStorage<number[]>(
  "favoriteMovies",
  []
);
```

**Проблема без LocalStorage:**

- Пользователь добавляет фильмы в избранное
- Обновляет страницу или закрывает вкладку
- Все данные теряются, пользователь должен заново выбирать

**С LocalStorage:**

- Избранное сохраняется в браузере
- При перезагрузке страницы данные восстанавливаются

Смотреть в `src/hooks/useLocalStorage.ts`, `src/App.tsx`

## Установка и запуск

```bash
# Установка зависимостей
npm install

# Запуск dev-сервера
npm run dev
```
